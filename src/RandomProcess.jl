abstract  RandomProcess

doc"""
  SampleInterval(tmin, tmax, npts)

Time interval for evaluluation of randowm process where tmin is the start time, tmax the end time
and npts the number of points in the sample.
"""
immutable SampleInterval{T<:Integer, U<:Real}
  npts::U
  tmin::T
  tmax::T
  SampleInterval(npts::T, tmax::U, tmin::U) = tmax > tmin && npts > zero(npts) ? new(npts, tmax, tmin) : error("must have tmax > tmin && npts > 0")
end

# outer constructors
SampleInterval{T<:Integer, U<:Real}(npts::T, tmax::U, tmin::U) = SampleInterval{T, U}(npts, tmax, tmin)
SampleInterval(npts::Integer, tmax::Integer, tmin::Integer) = SampleInterval(UInt64(npts), Float64(tmax), Float64(tmin))
SampleInterval(npts::Real, tmax::Real, tmin::Real) = SampleInterval(UInt64(npts), promote(tmax, tmin)...)
SampleInterval(npts::Integer, tmax::Real, tmin::Real) = SampleInterval(UInt64(npts), promote(tmax, tmin)...)
SampleInterval(npts::Integer, tmax::Real) = SampleInterval(npts, tmax, zero(tmax))

# conversions
convert{T<:Integer, U<:Real, V<:Integer, W<:Real}(::Type{SampleInterval{T, U}}, npts::V, tmax::W, tmin::W) = SampleInterval(T(npts), U(tmax), U(tmin))
convert{T<:Integer, U<:Real, V<:Integer, W<:Real}(::Type{SampleInterval{T, U}}, s::SampleInterval{V, W}) = SampleInterval(T(s.npts), U(s.tmax), U(s.tmin))
convert{T<:Integer, U<:Real, V<:Integer, W<:Real}(::Type{SampleInterval{T, U}}, s::SampleInterval{V, W}) = SampleInterval(T(s.npts), U(s.tmax))

# parameters
params(sampleInterval::SampleInterval) = (sampleInterval.npts, sampleInterval.tmax, sampleInterval.tmin)

function samples(sampleInterval::SampleInterval)
    collect(linspace(sampleInterval.tmin, sampleInterval.tmax, sampleInterval.npts))
end

doc"""
  BrownianMotion(μ, σ)

Brownian motion generated by a normal distribution with standard deviation σ.

https://en.wikipedia.org/wiki/Brownian_motion
"""
immutable BrownianMotion{T<:Real} <: RandomProcess
  σ::T
  BrownianMotion(σ) = σ > zero(σ) ? new(σ) : error("must have σ > 0")
end

# outer constructors
BrownianMotion{T<:Real}(σ::T) = BrownianMotion{T}(σ)
BrownianMotion(σ::Integer) = BrownianMotion(Float64(σ))
BrownianMotion() = BrownianMotion(1.0)

# conversions
convert{T<:Real, U<:Real}(::Type{BrownianMotion{T}}, σ::U) = BrownianMotion(T(σ))
convert{T<:Real, U<:Real}(::Type{BrownianMotion{T}}, b::BrownianMotion{U}) = BrownianMotion(T(b.σ))

# parameters
params(randomProcess::BrownianMotion) = (randomProcess.σ)

# generation
function rand(randomProcess::BrownianMotion, sampleInterval::SampleInterval)
  Δt = (sampleInterval.tmax - sampleInterval.tmin) / sampleInterval.npts
  dist = Normal(randomProcess.μ, randomProcess.σ)
end
